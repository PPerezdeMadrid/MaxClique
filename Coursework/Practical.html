<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Practical</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
   subequations: "0",
   section: "",
   loader: {
     load: ['[tex]/tagformat', '[tex]/textmacros'],
   },
   startup: {
     ready() {
       // These would be replaced by import commands if you wanted to make
       // a proper extension.
       const Configuration = MathJax._.input.tex.Configuration.Configuration;
       const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
       const Macro = MathJax._.input.tex.Symbol.Macro;
       const TexError = MathJax._.input.tex.TexError.default;
       const ParseUtil = MathJax._.input.tex.ParseUtil.default;
       const expandable = MathJax._.util.Options.expandable;

        // Insert the replacement string into the TeX string, and check
        // that there haven't been too many maxro substitutions (prevents
        // infinite loops).
        const useArgument = (parser, text) => {
          parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
          parser.i = 0;
          if (++parser.macroCount > parser.configuration.options.maxMacros) {
            throw new TexError('MaxMacroSub1',
            'MathJax maximum macro substitution count exceeded; ' +
            'is there a recursive macro call?');
          }
        }

        // Create the command map for:
        //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
        new CommandMap('Lwarp-macros', {
          ifstar: 'IfstarFunction',
          ifnextchar: 'IfnextcharFunction',
          ifblank: 'IfblankFunction',
          ifstrequal: 'IfstrequalFunction',
          gsubstitute: 'GsubstituteFunction',
          seteqnumber: 'SeteqnumberFunction'
        }, {
          // This function implements an ifstar macro.
          IfstarFunction(parser, name) {
             const resultstar = parser.GetArgument(name);
             const resultnostar = parser.GetArgument(name);
             const star = parser.GetStar();                 // true if there is a *
             useArgument(parser, star ? resultstar : resultnostar);
          },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
             let whichchar = parser.GetArgument(name);
             if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
               // $ syntax highlighting
               whichchar = String.fromCodePoint(parseInt(whichchar));
             }
             const resultnextchar = parser.GetArgument(name);
             const resultnotnextchar = parser.GetArgument(name);
             const gotchar = (parser.GetNext() === whichchar);
             useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
             const blankarg = parser.GetArgument(name);
             const resultblank = parser.GetArgument(name);
             const resultnotblank = parser.GetArgument(name);
             const isblank = (blankarg.trim() == "");
             useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
             const strequalfirst = parser.GetArgument(name);
             const strequalsecond = parser.GetArgument(name);
             const resultequal = parser.GetArgument(name);
             const resultnotequal = parser.GetArgument(name);
             const isequal = (strequalfirst == strequalsecond);
             useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
             const gsubfirst = parser.GetArgument(name);
             const gsubsecond = parser.GetArgument(name);
             const gsubthird = parser.GetArgument(name);
             let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
             useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

        });

        // Create the Lwarp-macros package
        Configuration.create('Lwarp-macros', {
          handler: {macro: ['Lwarp-macros']}
        });

        MathJax.startup.defaultReady();

        // For forward references:
        MathJax.startup.input[0].preFilters.add(({math}) => {
          if (math.inputData.recompile){
              MathJax.config.subequations = math.inputData.recompile.subequations;
              MathJax.config.section = math.inputData.recompile.section;
          }
        });
        MathJax.startup.input[0].postFilters.add(({math}) => {
          if (math.inputData.recompile){
              math.inputData.recompile.subequations = MathJax.config.subequations;
              math.inputData.recompile.section = MathJax.config.section;
          }
        });

          // For \left, \right with unicode-math:
          const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
          const {Symbol} = MathJax._.input.tex.Symbol;
          const {MapHandler} = MathJax._.input.tex.MapHandler;
          const delimiter = MapHandler.getMap('delimiter');
          delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
          delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
          delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
          delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
          delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
          delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
          delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
          delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
          delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
          delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
          delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
          delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
          delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
          delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
          delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
          delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
          delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
          delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
          delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
          delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
          delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
          delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
          delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
          delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
          delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
          delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
          delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
          delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
          delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
          delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
          delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
          delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
          delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
          delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
          delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
          delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
          delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
          delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
          delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
    }     // ready
  },      // startup

  tex: {
    packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
    tags: "ams",
        tagformat: {
            number: function (n) {
                 if(MathJax.config.subequations==0)
                     return(MathJax.config.section + n);
                 else
                     return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
  }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<div class="bodywithoutsidetoc">


<main class="bodycontainer">


<section class="textbody">

<a id="Practical-autofile-0"></a>

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

</div>

<a id="Practical-autopage-1"></a>
<div class="titlepage">

<h1>CS5015 Practical: Searching for Maximum Cliques</h1>


<div class="author">


<div class="oneauthor">

<p>
Ruth Hoffmann <kbd><cs5015.staff@st-andrews.ac.uk></kbd>
</p>
</div>

</div>


<div class="titledate">

<p>
Due date: 17th November, 21:00<br />
60% of the coursework component of the module (36% of the overall module assessment)<br />
MMS shows practical weighting and definitive date and time for deadlines
</p>
</div>

</div>
<div class="center">

<p>
<b>You are expected to have read and understood all the information in this specification and any accompanying documents at least a week before the deadline. You must contact the lecturers regarding any queries well in advance of the deadline.</b>
</p>
</div>
<!--
...... subsection Goal ......
-->
<h5 id="autosec-4">Goal</h5>
<a id="Practical-autopage-4"></a>


<p>
Be able to identify the impact of an heuristic on an algorithm.
</p>
<!--
...... subsection Background ......
-->
<h5 id="autosec-5">Background</h5>
<a id="Practical-autopage-5"></a>


<p>
The maximum clique problem asks, when given a graph \(G=(V,E)\) with \(V\) vertices and \(E\) edges, then what is the largest subset of \(V\) that is a clique in \(G\)? A clique is a set of vertices which are all adjacent to each other, i.e. each distinct pair of vertices in a clique are
adjacent. For example, Figure <a href="Practical.html#fig:ex">1</a> shows a clique of size 4 (highlighted in red) inside a larger graph. There could be more of the same size, but there are none with more vertices.
</p>

<p>
This practical will explore how to improve a search algorithm which looks for a maximum clique in a graph.
</p>

<figure id="autoid-1" class="figure ">
<div class="center">

<p>
<span
    id="lateximage-Practical-1"
    class="lateximagesource"
><!--
--><img
   src="MCExample.png"
   alt="Graph with a maximum clique highlighted"
   style=""
   class="lateximage"
></span>
</p>

<div class="figurecaption">
<p>
Figure 1:&nbsp;Graph with a maximum clique highlighted.
</p>
</div>

<a id="fig:ex"></a>

</div>

</figure>
<!--
...... subsection The Assignment ......
-->
<h5 id="autosec-9">The Assignment</h5>
<a id="Practical-autopage-9"></a>


<p>
You are provided code and graph instances. The code consists of a parser (<kbd>parser.py</kbd>) which reads in a file in the <kbd>DIMACS</kbd> folder and returns a graph in a usable format.
</p>

<p>
The <kbd>DIMACS</kbd> folder contains graph instances which are provided for this practical. The source of the files is the DIMACS benchmark set found on <a href="https://iridia.ulb.ac.be/~fmascia/maximum_clique/DIMACS-benchmark" target="_blank"
>https://iridia.ulb.ac.be/~fmascia/maximum_clique/DIMACS-benchmark</a>. I have provided you with a subset of this benchmark set. See Hints for more information.
</p>

<p>
The code in <kbd>search.py</kbd> takes the graph from <kbd>parser.py</kbd> and then finds the maximum clique using some search algorithm with an inefficient heuristic.
</p>

<p>
The code provided to you has been generated using Claude Sonnet 4.5. The main (slightly redacted) prompt was
</p>
<div class="center">

<p>
<kbd>Write an inefficient &lt;search&gt; algorithm for the maximum clique problem. The input graph is created by parser.py.</kbd>
</p>
</div>

<p>
It was then followed with some additional queries to fix how <kbd>parser.py</kbd> returns the graph and how <kbd>search.py</kbd> handles it. The comments were also generated by Claude and have not been checked for correctness.
</p>

<p>
The search algorithm has been redacted as it is part of your assignment to identify which algorithm is implemented. Note that the provided code is purposefully inefficient and thus will take a long time for some of the provided benchmark instances.
</p>

<p>
Below are the steps that you have to implement.
</p>

<ul style="list-style-type:none">

<li>
<p>
1. First identify which type of search algorithm is provided in <kbd>search.py</kbd>. Explain your answer.
</p>

</li>
<li>

<p>
2. Extend/augment the code to be more efficient. Copy the code in <kbd>search.py</kbd> to a new file and extend it. Do <em>not</em> change the underlying search algorithm structure (i.e. change the search type). You <em>can</em> improve parts of the algorithm. Make it clear
in the code where and what your changes are.
</p>

</li>
<li>

<p>
3. Explain your changes to the search code.
</p>

</li>
<li>

<p>
4. Run an analysis of the original algorithm against your improved version. Use the provided instances in the <kbd>DIMACS</kbd> folder as your test bed. You can create graphs using any tools of your choosing (Excel is perfectly reasonable). You may extend the set of instances with
the rest of the benchmark set if you want to, but beware that some of them are difficult to solve.
</p>

</li>
<li>

<p>
5. Show the results of the original code vs your code. Explain by how much and how the improvements are being exhibited.
</p>

</li>
<li>

<p>
6. Provide README or script to run your analysis. Note that the instructions have to be clear to be able for anyone to re-compute your results.
</p>

</li>
<li>

<p>
7. Write a report, see the next section for more information.
</p>
</li>
</ul>
<!--
...... subsection Report ......
-->
<h5 id="autosec-11">Report</h5>
<a id="Practical-autopage-11"></a>


<p>
In your report you need to clearly and succinctly explain all of the above steps. The report should address the following:
</p>
<ul style="list-style-type:none">

<li>
<p>
• What is the algorithm that has been provided?
</p>


</li>
<li>


<p>
• What is the the improvement that you added to the algorithm?
</p>


</li>
<li>


<p>
• How are you expecting the improvement to impact the algorithm?
</p>


</li>
<li>


<p>
• An analysis with evidence of how the improvement impacted the algorithm. Including explanations of any outliers.
</p>


</li>
<li>


<p>
• Any testing which was done to confirm that the improved algorithm still works correctly.
</p>
</li>
</ul>

<p>
Please note that the aim of the report is to be concise and clear. The report has an <em>advisory word limit of 1800 words</em>. You <em>do not</em> have to reach this word limit.
</p>
<!--
...... subsection Requirements ......
-->
<h5 id="autosec-12">Requirements</h5>
<a id="Practical-autopage-12"></a>


<p>
You should submit two elements to MMS (compressed as a zip file):
</p>
<ul style="list-style-type:none">

<li>
<p>
• All code: the provided code, your code with the benchmark instances, and your README.
</p>


</li>
<li>


<p>
• A compact report (as a PDF file) presenting work as described above.
</p>
</li>
</ul>
<!--
...... subsection Marking ......
-->
<h5 id="autosec-13">Marking</h5>
<a id="Practical-autopage-13"></a>


<p>
Your mark will depend on the overall quality and completeness of your submission, including the depth of your analysis, and the extent to which you evidence your findings. The submission will be marked on the University’s common reporting scale, according to the mark descriptors
given in the CS Student Handbook (at <a href="https://info.cs.st-andrews.ac.uk/student-handbook/learning-teaching/feedback.html#Mark_Descriptors" target="_blank"
>https://info.cs.st-andrews.ac.uk/student-handbook/learning-teaching/feedback.html#Mark_Descriptors</a>).
</p>
<!--
...... subsection Lateness ......
-->
<h5 id="autosec-14">Lateness</h5>
<a id="Practical-autopage-14"></a>


<p>
The standard penalty for late submission applies (Scheme A: 1 mark per 24 hour period, or part thereof):
</p>

<p>
<a href="https://info.cs.st-andrews.ac.uk/student-handbook/learning-teaching/assessment.html\#lateness-penalties" target="_blank"
>https://info.cs.st-andrews.ac.uk/student-handbook/learning-teaching/assessment.html#lateness-penalties</a>
</p>
<!--
...... subsection Good Academic Practice ......
-->
<h5 id="autosec-15">Good Academic Practice</h5>
<a id="Practical-autopage-15"></a>


<p>
I would remind you to ensure you are following the relevant guidelines on good academic practice as outlined at
</p>

<p>
<a href="https://www.st-andrews.ac.uk/education/handbook/good-academic-practice/" target="_blank" >https://www.st-andrews.ac.uk/education/handbook/good-academic-practice/</a>
</p>
<!--
...... subsection Hints for completing the practical ......
-->
<h5 id="autosec-16">Hints for completing the practical</h5>
<a id="Practical-autopage-16"></a>


<ul style="list-style-type:none">

<li>
<p>
1. The Maximum Clique Problem has had many different approaches, you might want to look into academic literature for some inspiration for how to make the search more efficient. Some are listed here <a href="https://www.csplib.org/Problems/prob074/references/"
target="_blank" >https://www.csplib.org/Problems/prob074/references/</a>. Note that some of these papers might only be accessible through the University Library.
</p>

</li>
<li>

<p>
2. The benchmark set has been shortened to contain instances that should be solvable with an efficient algorithm within 5mins (each). Some will be unsolvable with the provided algorithm (because it is that inefficient).
</p>

</li>
<li>

<p>
3. Use the information on the benchmark set webpage to check if your algorithm is still correct.
</p>

</li>
<li>

<p>
4. An FAQ document will be released on StudRes and updated with questions from your peers. Keep an eye on it.
</p>

</li>
<li>

<p>
5. I do not recommend attempting to parallelise the search. Note that that also entails changing the search type which you are not supposed to do.
</p>
</li>
</ul>

<a id="Practical-autofile-last"></a>
</section>

</main>

</div>

</body>
</html>
